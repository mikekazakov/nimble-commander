// Copyright (C) 2024 Michael Kazakov. Subject to GNU General Public License version 3.
#include "Tags.h"
#include "UnitTests_main.h"
#include <set>
#include <fmt/core.h>
#include <fmt/std.h>
#include <fmt/printf.h>
#include <fmt/os.h>
#include <Utility/ObjCpp.h>
#include <Base/CommonPaths.h>
#include <Base/algo.h>
#include <Cocoa/Cocoa.h>

using nc::utility::Tags;

#define PREFIX "nc::utility::Tags "

TEST_CASE(PREFIX "Rejects corrupt data")
{
    CHECK(Tags::ParseMDItemUserTags({}).empty());

    // corrupt the header
    for( size_t i = 0; i < 8; ++i ) {
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        ++plist[i];
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    // trim the header
    for( size_t i = 0; i < 8; ++i ) {
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), i}).empty());
    }
    { // zero objects
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // zero offset size
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong offset table location
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        plist[sizeof(plist) - 1] = 0;
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
        plist[sizeof(plist) - 1] = 255;
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong color
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x46, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong string length
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong string length, vl version
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x30, 0x54,
                           0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20,
                           0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69,
                           0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62,
                           0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
}

TEST_CASE(PREFIX "Simple cases")
{
    struct TC {
        std::vector<unsigned char> bytes;
        std::string expected_label;
        Tags::Color expected_color;
    } const tcs[] = {
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x54, 0x4e, 0x6f, 0x6e, 0x65, 0x08, 0x0a,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f},
         "None",
         Tags::Color::None},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x47, 0x72, 0x61, 0x79, 0x0a, 0x31,
          0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
         "Gray",
         Tags::Color::Gray},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x57, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x0a, 0x32,
          0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12},
         "Green",
         Tags::Color::Green},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x0a,
          0x33, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         "Purple",
         Tags::Color::Purple},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34,
          0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
         "Blue",
         Tags::Color::Blue},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x0a,
          0x35, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         "Yellow",
         Tags::Color::Yellow},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65, 0x64, 0x0a, 0x36, 0x08,
          0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
         "Red",
         Tags::Color::Red},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x0a,
          0x37, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         "Orange",
         Tags::Color::Orange}};
    for( auto &tc : tcs ) {
        auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<const std::byte *>(tc.bytes.data()), tc.bytes.size()});
        REQUIRE(tags.size() == 1);
        CHECK(tags[0] == Tags::Tag(&tc.expected_label, tc.expected_color));
    }
}

TEST_CASE(PREFIX "Can read long ASCII labels")
{
    uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x2f, 0x54, 0x68, 0x69,
                       0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x67,
                       0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73,
                       0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c};
    auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)});
    REQUIRE(tags.size() == 1);
    const std::string label = "This is a very long and meaningless tag label";
    CHECK(tags[0] == Tags::Tag(&label, Tags::Color::Red));
}

TEST_CASE(PREFIX "Supports Unicode labels")
{
    struct TC {
        std::vector<unsigned char> bytes;
        std::string expected_label;
        Tags::Color expected_color;
    } const tcs[] = {
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6b, 0x04, 0x1f, 0x04, 0x40, 0x04, 0x38,
          0x04, 0x32, 0x04, 0x35, 0x04, 0x42, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x0a, 0x00, 0x34, 0x08,
          0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21},
         "Привет!!!",
         Tags::Color::Blue},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x21, 0x04, 0x38,
          0x04, 0x3d, 0x04, 0x38, 0x04, 0x39, 0x00, 0x0a, 0x00, 0x34, 0x08, 0x0a, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19},
         "Синий",
         Tags::Color::Blue},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x65, 0x04, 0x21, 0x04,
          0x35, 0x04, 0x40, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15},
         "Серый",
         Tags::Color::Gray},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x69, 0x04, 0x17, 0x04, 0x35, 0x04,
          0x3b, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4b, 0x04, 0x39, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d},
         "Зеленый",
         Tags::Color::Green},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x69, 0x04, 0x1e, 0x04, 0x40, 0x04,
          0x30, 0x04, 0x3d, 0x04, 0x36, 0x04, 0x35, 0x04, 0x32, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d},
         "Оранжевый",
         Tags::Color::Orange},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x1b, 0x04, 0x38,
          0x04, 0x3b, 0x04, 0x3e, 0x04, 0x32, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19},
         "Лиловый",
         Tags::Color::Purple},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x1a, 0x04, 0x40,
          0x04, 0x30, 0x04, 0x41, 0x04, 0x3d, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19},
         "Красный",
         Tags::Color::Red},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x66, 0x04, 0x16, 0x04, 0x35,
          0x04, 0x3b, 0x04, 0x42, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17},
         "Желтый",
         Tags::Color::Yellow},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6f, 0x10, 0x52, 0x04, 0x2d, 0x04, 0x42, 0x04,
          0x3e, 0x00, 0x20, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4c, 0x00, 0x20, 0x04, 0x34, 0x04,
          0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x3d, 0x04, 0x3e, 0x04, 0x35, 0x00, 0x20, 0x04, 0x38, 0x04, 0x3c, 0x04,
          0x4f, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x42, 0x04, 0x4d, 0x04, 0x33, 0x04,
          0x30, 0x00, 0x20, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x30, 0x00, 0x20, 0x04,
          0x3a, 0x04, 0x3e, 0x04, 0x42, 0x04, 0x3e, 0x04, 0x40, 0x04, 0x3e, 0x04, 0x33, 0x04, 0x3e, 0x00, 0x20, 0x04,
          0x42, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x3d, 0x04, 0x3e, 0x00, 0x20, 0x04, 0x3d, 0x04, 0x35, 0x00, 0x20, 0x04,
          0x3f, 0x04, 0x3e, 0x04, 0x3c, 0x04, 0x35, 0x04, 0x41, 0x04, 0x42, 0x04, 0x38, 0x04, 0x42, 0x04, 0x41, 0x04,
          0x4f, 0x00, 0x20, 0x04, 0x32, 0x00, 0x20, 0x04, 0x47, 0x04, 0x35, 0x04, 0x42, 0x04, 0x4b, 0x04, 0x40, 0x04,
          0x35, 0x00, 0x20, 0x04, 0x31, 0x04, 0x38, 0x04, 0x42, 0x04, 0x30, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb1},
         "Это очень длинное имя для тэга  длина которого точно не поместится в четыре бита",
         Tags::Color::Green},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6a, 0xd8, 0x3e, 0xdd, 0x13, 0xd8, 0x3e,
          0xdd, 0x78, 0xd8, 0x3e, 0xdd, 0x29, 0xd8, 0x3e, 0xdd, 0x73, 0xd8, 0x3d, 0xde, 0x0f, 0x08, 0x0a, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f},
         "🤓🥸🤩🥳😏",
         Tags::Color::None},
    };
    for( auto &tc : tcs ) {
        INFO(fmt::format("{} - {}", tc.expected_label, std::to_underlying(tc.expected_color)));
        auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<const std::byte *>(tc.bytes.data()), tc.bytes.size()});
        REQUIRE(tags.size() == 1);
        CHECK(tags[0] == Tags::Tag(&tc.expected_label, tc.expected_color));
    }
}

TEST_CASE(PREFIX "Can parse muliple labels at once")
{
    uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa8, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                       0x07, 0x08, 0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34, 0x56, 0x47, 0x72, 0x65, 0x79, 0x0a,
                       0x31, 0x57, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x0a, 0x32, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67,
                       0x65, 0x0a, 0x37, 0x58, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x0a, 0x33, 0x55, 0x52, 0x65,
                       0x64, 0x0a, 0x36, 0x58, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x0a, 0x35, 0x54, 0x48, 0x6f,
                       0x6d, 0x65, 0x08, 0x11, 0x18, 0x1f, 0x27, 0x30, 0x39, 0x3f, 0x48, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d};
    auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)});
    std::set<std::string> labels;
    auto label = [&labels](const char *_l) { return &*labels.emplace(_l).first; };
    CHECK(tags == std::vector<Tags::Tag>{{label("Blue"), Tags::Color::Blue},
                                         {label("Grey"), Tags::Color::Gray},
                                         {label("Green"), Tags::Color::Green},
                                         {label("Orange"), Tags::Color::Orange},
                                         {label("Purple"), Tags::Color::Purple},
                                         {label("Red"), Tags::Color::Red},
                                         {label("Yellow"), Tags::Color::Yellow},
                                         {label("Home"), Tags::Color::None}});
}

TEST_CASE(PREFIX "Can read from a file")
{
    TempTestDir dir;
    const auto path = dir.directory / "f.txt";
    struct TC {
        NSURLResourceKey key;
        id value;
        std::string expected_label;
        Tags::Color expected_color;
    } tcs[] = {
        // TODO: figure out a way of getting current Finder tags, otherwise these tests are setup-dependent
        // {NSURLTagNamesKey, @[@"Home"], "Home", Tags::Color::None},
        // {NSURLTagNamesKey, @[@"Grey"], "Grey", Tags::Color::Gray},
        // {NSURLTagNamesKey, @[@"Green"], "Green", Tags::Color::Green},
        // {NSURLTagNamesKey, @[@"Purple"], "Purple", Tags::Color::Purple},
        // {NSURLTagNamesKey, @[@"Blue"], "Blue", Tags::Color::Blue},
        // {NSURLTagNamesKey, @[@"Yellow"], "Yellow", Tags::Color::Yellow},
        // {NSURLTagNamesKey, @[@"Red"], "Red", Tags::Color::Red},
        // {NSURLTagNamesKey, @[@"Orange"], "Orange", Tags::Color::Orange},
        {NSURLLabelNumberKey, @(1), "Gray", Tags::Color::Gray},
        {NSURLLabelNumberKey, @(2), "Green", Tags::Color::Green},
        {NSURLLabelNumberKey, @(3), "Purple", Tags::Color::Purple},
        {NSURLLabelNumberKey, @(4), "Blue", Tags::Color::Blue},
        {NSURLLabelNumberKey, @(5), "Yellow", Tags::Color::Yellow},
        {NSURLLabelNumberKey, @(6), "Red", Tags::Color::Red},
        {NSURLLabelNumberKey, @(7), "Orange", Tags::Color::Orange},
    };
    for( auto &tc : tcs ) {
        INFO(fmt::format("{} - {} - {}", tc.key.UTF8String, tc.expected_label, std::to_underlying(tc.expected_color)));
        close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR));
        NSURL *url = [[NSURL alloc] initFileURLWithFileSystemRepresentation:path.c_str()
                                                                isDirectory:false
                                                              relativeToURL:nil];
        CHECK([url setResourceValue:tc.value forKey:tc.key error:nil]);
        auto tags = Tags::ReadTags(path);
        REQUIRE(tags.size() == 1);
        CHECK(tags[0].Label() == tc.expected_label);
        CHECK(tags[0].Color() == tc.expected_color);
        unlink(path.c_str());
    }
}

TEST_CASE(PREFIX "BuildMDItemUserTags")
{
    std::set<std::string> labels;
    auto tag = [&labels](const char *_l, Tags::Color _c) { return Tags::Tag(&*labels.emplace(_l).first, _c); };

    struct TC {
        std::vector<Tags::Tag> labels;
        std::vector<unsigned char> expected_bytes;
    } const tcs[] = {
        {{}, {}},
        {{tag("None", Tags::Color::None)},
         {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x54, 0x4e, 0x6f, 0x6e, 0x65, 0x08, 0x0a,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f}},
        {{tag("Gray", Tags::Color::Gray)},
         {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x47, 0x72, 0x61, 0x79, 0x0a, 0x31,
          0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11}},
        {{tag("Green", Tags::Color::Green)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x57, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x0a, 0x32,
           0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12}}},
        {{tag("Purple", Tags::Color::Purple)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x0a,
           0x33, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13}}},
        {{tag("Blue", Tags::Color::Blue)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34,
           0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11}}},
        {{tag("Yellow", Tags::Color::Yellow)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x0a,
           0x35, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13}}},
        {{tag("Red", Tags::Color::Red)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65, 0x64, 0x0a, 0x36, 0x08,
           0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10}}},
        {{tag("Orange", Tags::Color::Orange)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x0a,
           0x37, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
           0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13}}},
        {{tag("Blue", Tags::Color::Blue),
          tag("Grey", Tags::Color::Gray),
          tag("Green", Tags::Color::Green),
          tag("Orange", Tags::Color::Orange),
          tag("Purple", Tags::Color::Purple),
          tag("Red", Tags::Color::Red),
          tag("Yellow", Tags::Color::Yellow),
          tag("Home", Tags::Color::None)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa8, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
           0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34, 0x56, 0x47, 0x72, 0x65, 0x79, 0x0a, 0x31, 0x57, 0x47, 0x72,
           0x65, 0x65, 0x6e, 0x0a, 0x32, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x0a, 0x37, 0x58, 0x50, 0x75,
           0x72, 0x70, 0x6c, 0x65, 0x0a, 0x33, 0x55, 0x52, 0x65, 0x64, 0x0a, 0x36, 0x58, 0x59, 0x65, 0x6c, 0x6c,
           0x6f, 0x77, 0x0a, 0x35, 0x54, 0x48, 0x6f, 0x6d, 0x65, 0x08, 0x11, 0x18, 0x1f, 0x27, 0x30, 0x39, 0x3f,
           0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d}}},
        {{tag("This is a very long and meaningless tag label", Tags::Color::Red)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x2f, 0x54, 0x68, 0x69,
           0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x67,
           0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73,
           0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c}}},
        {{tag("Привет!!!", Tags::Color::Blue)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6b, 0x04, 0x1f, 0x04, 0x40, 0x04, 0x38,
           0x04, 0x32, 0x04, 0x35, 0x04, 0x42, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x0a, 0x00, 0x34, 0x08,
           0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21}}},
        {{tag("Синий", Tags::Color::Blue)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x21, 0x04, 0x38,
           0x04, 0x3d, 0x04, 0x38, 0x04, 0x39, 0x00, 0x0a, 0x00, 0x34, 0x08, 0x0a, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19}}},
        {{tag("Зеленый", Tags::Color::Green)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x69, 0x04, 0x17, 0x04, 0x35, 0x04,
           0x3b, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4b, 0x04, 0x39, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d}}},
        {{tag("Это очень длинное имя для тэга  длина которого точно не поместится в четыре бита", Tags::Color::Green)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6f, 0x10, 0x52, 0x04, 0x2d, 0x04, 0x42, 0x04,
           0x3e, 0x00, 0x20, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4c, 0x00, 0x20, 0x04, 0x34, 0x04,
           0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x3d, 0x04, 0x3e, 0x04, 0x35, 0x00, 0x20, 0x04, 0x38, 0x04, 0x3c, 0x04,
           0x4f, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x42, 0x04, 0x4d, 0x04, 0x33, 0x04,
           0x30, 0x00, 0x20, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x30, 0x00, 0x20, 0x04,
           0x3a, 0x04, 0x3e, 0x04, 0x42, 0x04, 0x3e, 0x04, 0x40, 0x04, 0x3e, 0x04, 0x33, 0x04, 0x3e, 0x00, 0x20, 0x04,
           0x42, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x3d, 0x04, 0x3e, 0x00, 0x20, 0x04, 0x3d, 0x04, 0x35, 0x00, 0x20, 0x04,
           0x3f, 0x04, 0x3e, 0x04, 0x3c, 0x04, 0x35, 0x04, 0x41, 0x04, 0x42, 0x04, 0x38, 0x04, 0x42, 0x04, 0x41, 0x04,
           0x4f, 0x00, 0x20, 0x04, 0x32, 0x00, 0x20, 0x04, 0x47, 0x04, 0x35, 0x04, 0x42, 0x04, 0x4b, 0x04, 0x40, 0x04,
           0x35, 0x00, 0x20, 0x04, 0x31, 0x04, 0x38, 0x04, 0x42, 0x04, 0x30, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb1}}},
        {{tag("🤓🥸🤩🥳😏", Tags::Color::None)},
         {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6a, 0xd8, 0x3e, 0xdd, 0x13, 0xd8, 0x3e,
           0xdd, 0x78, 0xd8, 0x3e, 0xdd, 0x29, 0xd8, 0x3e, 0xdd, 0x73, 0xd8, 0x3d, 0xde, 0x0f, 0x08, 0x0a, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f}}},
    };

    for( const auto &tc : tcs ) {
        auto bytes = Tags::BuildMDItemUserTags(tc.labels);
        CHECK(tc.expected_bytes ==
              std::vector<unsigned char>{reinterpret_cast<const unsigned char *>(bytes.data()),
                                         reinterpret_cast<const unsigned char *>(bytes.data() + bytes.size())});
    }
}

TEST_CASE(PREFIX "Our tags can be read back by Cocoa")
{
    std::set<std::string> labels;
    auto tag = [&labels](const char *_l, Tags::Color _c) { return Tags::Tag(&*labels.emplace(_l).first, _c); };
    TempTestDir dir;
    const auto path = dir.directory / "f.txt";
    close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR));
    struct TC {
        std::vector<Tags::Tag> tags;
        NSArray<NSString *> *expected_labels;
        Tags::Color expected_color;
    } const tcs[] = {
        {{}, @[], Tags::Color::None},
        {{tag("Hello!", Tags::Color::Green)}, @[@"Hello!"], Tags::Color::Green},
        {{tag("N", Tags::Color::None)}, @[@"N"], Tags::Color::None},
        {{tag("Gy", Tags::Color::Gray)}, @[@"Gy"], Tags::Color::Gray},
        {{tag("Gn", Tags::Color::Green)}, @[@"Gn"], Tags::Color::Green},
        {{tag("P", Tags::Color::Purple)}, @[@"P"], Tags::Color::Purple},
        {{tag("B", Tags::Color::Blue)}, @[@"B"], Tags::Color::Blue},
        {{tag("Y", Tags::Color::Yellow)}, @[@"Y"], Tags::Color::Yellow},
        {{tag("R", Tags::Color::Red)}, @[@"R"], Tags::Color::Red},
        {{tag("O", Tags::Color::Orange)}, @[@"O"], Tags::Color::Orange},
        {{tag("1", Tags::Color::Orange), tag("2", Tags::Color::Blue)}, @[@"1", @"2"], Tags::Color::Orange},
        {{tag("2", Tags::Color::Blue), tag("1", Tags::Color::Orange)}, @[@"2", @"1"], Tags::Color::Blue},
        {{tag("🤡", Tags::Color::Green)}, @[@"🤡"], Tags::Color::Green},
    };

    for( auto &tc : tcs ) {
        CHECK(Tags::WriteTags(path, tc.tags));
        NSURL *url = [[NSURL alloc] initFileURLWithFileSystemRepresentation:path.c_str()
                                                                isDirectory:false
                                                              relativeToURL:nil];

        id tag_names;
        CHECK([url getResourceValue:&tag_names forKey:NSURLTagNamesKey error:nil]);
        if( tc.expected_labels.count )
            CHECK([nc::objc_cast<NSArray>(tag_names) isEqualToArray:tc.expected_labels]);
        else
            CHECK(tag_names == nil);

        id number;
        CHECK([url getResourceValue:&number forKey:NSURLLabelNumberKey error:nil]);
        CHECK(nc::objc_cast<NSNumber>(number).integerValue == std::to_underlying(tc.expected_color));
    }
}

TEST_CASE(PREFIX "Spotlight detects items with new tags invented by NC")
{
    // Need to place these temp files into an indexable location (which the temp dir is not)
    auto basepath = std::filesystem::path{nc::base::CommonPaths::Library()} / "__nc_testing_tags_ut__";
    std::filesystem::create_directory(basepath);
    auto cleanup = at_scope_end([basepath] { std::filesystem::remove_all(basepath); });

    const std::string label =
        fmt::format("Hello! This is a new tag created via Nimble Commander! My PID is {}", getpid());
    const Tags::Color color = Tags::Color::Orange;

    {
        // Write a temp file with a newly invented tag
        const auto path = basepath / "f.txt";
        CHECK(close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
        CHECK(Tags::WriteTags(path, std::vector<Tags::Tag>{{&label, color}}));
        CHECK(system(fmt::format("mdimport {}", path.c_str()).c_str()) == 0);
    }

    // Try a few times to find the new tag via Spotlight, need multiple attempts since there's still a race condition
    // even after an explicit call to mdimport
    for( int attempt = 0; attempt < 10; ++attempt ) {
        auto all_tags = Tags::GatherAllItemsTags();
        if( std::ranges::find(all_tags, Tags::Tag{&label, color}) == all_tags.end() ) {
            std::this_thread::sleep_for(std::chrono::milliseconds{100});
            continue;
        }

        // Sucessfully found the newly created tag among all tags found via Spotlight, i.e. success
        return;
    }

    // Failed to find the new tag after the number of attempts
    FAIL();
}
