// Copyright (C) 2024 Michael Kazakov. Subject to GNU General Public License version 3.
#include "Tags.h"
#include "UnitTests_main.h"
#include <set>
#include <fmt/core.h>
#include <Utility/ObjCpp.h>
#include <Cocoa/Cocoa.h>

using nc::utility::Tags;

#define PREFIX "nc::utility::Tags "

TEST_CASE(PREFIX "Rejects corrupt data")
{
    CHECK(Tags::ParseMDItemUserTags({}).empty());

    // corrupt the header
    for( size_t i = 0; i < 8; ++i ) {
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        ++plist[i];
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    // trim the header
    for( size_t i = 0; i < 8; ++i ) {
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), i}).empty());
    }
    { // zero objects
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // zero offset size
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong offset table location
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        plist[sizeof(plist) - 1] = 0;
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
        plist[sizeof(plist) - 1] = 255;
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong color
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x46, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong string length
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong string length, vl version
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x30, 0x54,
                           0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20,
                           0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69,
                           0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62,
                           0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
}

TEST_CASE(PREFIX "Simple cases")
{
    struct TC {
        std::vector<unsigned char> bytes;
        std::string expected_label;
        Tags::Color expected_color;
    } const tcs[] = {
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x54, 0x4e, 0x6f, 0x6e, 0x65, 0x08, 0x0a,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f},
         "None",
         Tags::Color::None},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x47, 0x72, 0x61, 0x79, 0x0a, 0x31,
          0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
         "Gray",
         Tags::Color::Gray},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x57, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x0a, 0x32,
          0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12},
         "Green",
         Tags::Color::Green},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x0a,
          0x33, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         "Purple",
         Tags::Color::Purple},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34,
          0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
         "Blue",
         Tags::Color::Blue},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x0a,
          0x35, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         "Yellow",
         Tags::Color::Yellow},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65, 0x64, 0x0a, 0x36, 0x08,
          0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
         "Red",
         Tags::Color::Red},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x0a,
          0x37, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         "Orange",
         Tags::Color::Orange}};
    for( auto &tc : tcs ) {
        auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<const std::byte *>(tc.bytes.data()), tc.bytes.size()});
        REQUIRE(tags.size() == 1);
        CHECK(tags[0] == Tags::Tag(&tc.expected_label, tc.expected_color));
    }
}

TEST_CASE(PREFIX "Can read long ASCII labels")
{
    uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x2f, 0x54, 0x68, 0x69,
                       0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x67,
                       0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73,
                       0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c};
    auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)});
    REQUIRE(tags.size() == 1);
    const std::string label = "This is a very long and meaningless tag label";
    CHECK(tags[0] == Tags::Tag(&label, Tags::Color::Red));
}

TEST_CASE(PREFIX "Supports Unicode labels")
{
    struct TC {
        std::vector<unsigned char> bytes;
        std::string expected_label;
        Tags::Color expected_color;
    } const tcs[] = {
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6b, 0x04, 0x1f, 0x04, 0x40, 0x04, 0x38,
          0x04, 0x32, 0x04, 0x35, 0x04, 0x42, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x0a, 0x00, 0x34, 0x08,
          0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21},
         "–ü—Ä–∏–≤–µ—Ç!!!",
         Tags::Color::Blue},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6f, 0x10, 0x52, 0x04, 0x2d, 0x04, 0x42, 0x04,
          0x3e, 0x00, 0x20, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4c, 0x00, 0x20, 0x04, 0x34, 0x04,
          0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x3d, 0x04, 0x3e, 0x04, 0x35, 0x00, 0x20, 0x04, 0x38, 0x04, 0x3c, 0x04,
          0x4f, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x42, 0x04, 0x4d, 0x04, 0x33, 0x04,
          0x30, 0x00, 0x20, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x30, 0x00, 0x20, 0x04,
          0x3a, 0x04, 0x3e, 0x04, 0x42, 0x04, 0x3e, 0x04, 0x40, 0x04, 0x3e, 0x04, 0x33, 0x04, 0x3e, 0x00, 0x20, 0x04,
          0x42, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x3d, 0x04, 0x3e, 0x00, 0x20, 0x04, 0x3d, 0x04, 0x35, 0x00, 0x20, 0x04,
          0x3f, 0x04, 0x3e, 0x04, 0x3c, 0x04, 0x35, 0x04, 0x41, 0x04, 0x42, 0x04, 0x38, 0x04, 0x42, 0x04, 0x41, 0x04,
          0x4f, 0x00, 0x20, 0x04, 0x32, 0x00, 0x20, 0x04, 0x47, 0x04, 0x35, 0x04, 0x42, 0x04, 0x4b, 0x04, 0x40, 0x04,
          0x35, 0x00, 0x20, 0x04, 0x31, 0x04, 0x38, 0x04, 0x42, 0x04, 0x30, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb1},
         "–≠—Ç–æ –æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω–æ–µ –∏–º—è –¥–ª—è —Ç—ç–≥–∞  –¥–ª–∏–Ω–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ —Ç–æ—á–Ω–æ –Ω–µ –ø–æ–º–µ—Å—Ç–∏—Ç—Å—è –≤ —á–µ—Ç—ã—Ä–µ –±–∏—Ç–∞",
         Tags::Color::Green},
        {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6a, 0xd8, 0x3e, 0xdd, 0x13, 0xd8, 0x3e,
          0xdd, 0x78, 0xd8, 0x3e, 0xdd, 0x29, 0xd8, 0x3e, 0xdd, 0x73, 0xd8, 0x3d, 0xde, 0x0f, 0x08, 0x0a, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f},
         "ü§ìü•∏ü§©ü•≥üòè",
         Tags::Color::None},
    };
    for( auto &tc : tcs ) {
        auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<const std::byte *>(tc.bytes.data()), tc.bytes.size()});
        REQUIRE(tags.size() == 1);
        CHECK(tags[0] == Tags::Tag(&tc.expected_label, tc.expected_color));
    }
}

TEST_CASE(PREFIX "Can parse muliple labels at once")
{
    uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa8, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                       0x07, 0x08, 0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34, 0x56, 0x47, 0x72, 0x65, 0x79, 0x0a,
                       0x31, 0x57, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x0a, 0x32, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67,
                       0x65, 0x0a, 0x37, 0x58, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x0a, 0x33, 0x55, 0x52, 0x65,
                       0x64, 0x0a, 0x36, 0x58, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x0a, 0x35, 0x54, 0x48, 0x6f,
                       0x6d, 0x65, 0x08, 0x11, 0x18, 0x1f, 0x27, 0x30, 0x39, 0x3f, 0x48, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d};
    auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)});
    std::set<std::string> labels;
    auto label = [&labels](const char *_l) { return &*labels.emplace(_l).first; };
    CHECK(tags == std::vector<Tags::Tag>{{label("Blue"), Tags::Color::Blue},
                                         {label("Grey"), Tags::Color::Gray},
                                         {label("Green"), Tags::Color::Green},
                                         {label("Orange"), Tags::Color::Orange},
                                         {label("Purple"), Tags::Color::Purple},
                                         {label("Red"), Tags::Color::Red},
                                         {label("Yellow"), Tags::Color::Yellow},
                                         {label("Home"), Tags::Color::None}});
}

TEST_CASE(PREFIX "Can read from a file")
{
    TempTestDir dir;
    const auto path = dir.directory / "f.txt";
    struct TC {
        NSURLResourceKey key;
        id value;
        std::string expected_label;
        Tags::Color expected_color;
    } tcs[] = {
        // TODO: figure out a way of getting current Finder tags, otherwise these tests are setup-dependent
        // {NSURLTagNamesKey, @[@"Home"], "Home", Tags::Color::None},
        // {NSURLTagNamesKey, @[@"Grey"], "Grey", Tags::Color::Gray},
        // {NSURLTagNamesKey, @[@"Green"], "Green", Tags::Color::Green},
        // {NSURLTagNamesKey, @[@"Purple"], "Purple", Tags::Color::Purple},
        // {NSURLTagNamesKey, @[@"Blue"], "Blue", Tags::Color::Blue},
        // {NSURLTagNamesKey, @[@"Yellow"], "Yellow", Tags::Color::Yellow},
        // {NSURLTagNamesKey, @[@"Red"], "Red", Tags::Color::Red},
        // {NSURLTagNamesKey, @[@"Orange"], "Orange", Tags::Color::Orange},
        {NSURLLabelNumberKey, @(1), "Gray", Tags::Color::Gray},
        {NSURLLabelNumberKey, @(2), "Green", Tags::Color::Green},
        {NSURLLabelNumberKey, @(3), "Purple", Tags::Color::Purple},
        {NSURLLabelNumberKey, @(4), "Blue", Tags::Color::Blue},
        {NSURLLabelNumberKey, @(5), "Yellow", Tags::Color::Yellow},
        {NSURLLabelNumberKey, @(6), "Red", Tags::Color::Red},
        {NSURLLabelNumberKey, @(7), "Orange", Tags::Color::Orange},
    };
    for( auto &tc : tcs ) {
        INFO(fmt::format("{} - {} - {}", tc.key.UTF8String, tc.expected_label, std::to_underlying(tc.expected_color)));
        close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR));
        NSURL *url = [[NSURL alloc] initFileURLWithFileSystemRepresentation:path.c_str()
                                                                isDirectory:false
                                                              relativeToURL:nil];
        CHECK([url setResourceValue:tc.value forKey:tc.key error:nil]);
        auto tags = Tags::ReadTags(path);
        REQUIRE(tags.size() == 1);
        CHECK(tags[0].Label() == tc.expected_label);
        CHECK(tags[0].Color() == tc.expected_color);
        unlink(path.c_str());
    }
}
