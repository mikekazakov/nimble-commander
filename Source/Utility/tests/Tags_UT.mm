// Copyright (C) 2024 Michael Kazakov. Subject to GNU General Public License version 3.
#include "Tags.h"
#include "UnitTests_main.h"
#include <set>
#include <fmt/core.h>
#include <fmt/std.h>
#include <fmt/printf.h>
#include <fmt/os.h>
#include <Utility/ObjCpp.h>
#include <Base/CommonPaths.h>
#include <Base/algo.h>
#include <Cocoa/Cocoa.h>

using nc::utility::Tags;

#define PREFIX "nc::utility::Tags "

TEST_CASE(PREFIX "Rejects corrupt data")
{
    CHECK(Tags::ParseMDItemUserTags({}).empty());

    // corrupt the header
    for( size_t i = 0; i < 8; ++i ) {
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        ++plist[i];
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    // trim the header
    for( size_t i = 0; i < 8; ++i ) {
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), i}).empty());
    }
    { // zero objects
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // zero offset size
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong offset table location
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        plist[sizeof(plist) - 1] = 0;
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
        plist[sizeof(plist) - 1] = 255;
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong color
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                           0x64, 0x0a, 0x46, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong string length
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x52, 0x65,
                           0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
    { // wrong string length, vl version
        uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x30, 0x54,
                           0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20,
                           0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69,
                           0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62,
                           0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                           0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c};
        CHECK(Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)}).empty());
    }
}

TEST_CASE(PREFIX "Simple cases")
{
    struct TC {
        std::vector<unsigned char> bytes;
        std::string expected_label;
        Tags::Color expected_color;
    } const tcs[] = {
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x54, 0x4e, 0x6f, 0x6e, 0x65, 0x08, 0x0a,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f},
         .expected_label = "None",
         .expected_color = Tags::Color::None},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x47, 0x72,
                   0x61, 0x79, 0x0a, 0x31, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
         .expected_label = "Gray",
         .expected_color = Tags::Color::Gray},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x57, 0x47, 0x72,
                   0x65, 0x65, 0x6e, 0x0a, 0x32, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12},
         .expected_label = "Green",
         .expected_color = Tags::Color::Green},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x50, 0x75, 0x72,
                   0x70, 0x6c, 0x65, 0x0a, 0x33, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         .expected_label = "Purple",
         .expected_color = Tags::Color::Purple},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x42, 0x6c,
                   0x75, 0x65, 0x0a, 0x34, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11},
         .expected_label = "Blue",
         .expected_color = Tags::Color::Blue},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x59, 0x65, 0x6c,
                   0x6c, 0x6f, 0x77, 0x0a, 0x35, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         .expected_label = "Yellow",
         .expected_color = Tags::Color::Yellow},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65, 0x64, 0x0a, 0x36, 0x08,
                   0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
         .expected_label = "Red",
         .expected_color = Tags::Color::Red},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x4f, 0x72, 0x61,
                   0x6e, 0x67, 0x65, 0x0a, 0x37, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13},
         .expected_label = "Orange",
         .expected_color = Tags::Color::Orange}};
    for( auto &tc : tcs ) {
        auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<const std::byte *>(tc.bytes.data()), tc.bytes.size()});
        REQUIRE(tags.size() == 1);
        CHECK(tags[0] == Tags::Tag(&tc.expected_label, tc.expected_color));
    }
}

TEST_CASE(PREFIX "Can read long ASCII labels")
{
    uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x2f, 0x54, 0x68, 0x69,
                       0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20, 0x6c, 0x6f, 0x6e, 0x67,
                       0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73,
                       0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c};
    auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)});
    REQUIRE(tags.size() == 1);
    const std::string label = "This is a very long and meaningless tag label";
    CHECK(tags[0] == Tags::Tag(&label, Tags::Color::Red));
}

TEST_CASE(PREFIX "Supports Unicode labels")
{
    struct TC {
        std::vector<unsigned char> bytes;
        std::string expected_label;
        Tags::Color expected_color;
    } const tcs[] = {
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6b, 0x04, 0x1f, 0x04, 0x40, 0x04, 0x38,
                   0x04, 0x32, 0x04, 0x35, 0x04, 0x42, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x0a, 0x00, 0x34, 0x08,
                   0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21},
         .expected_label = "Привет!!!",
         .expected_color = Tags::Color::Blue},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x21, 0x04, 0x38,
                   0x04, 0x3d, 0x04, 0x38, 0x04, 0x39, 0x00, 0x0a, 0x00, 0x34, 0x08, 0x0a, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19},
         .expected_label = "Синий",
         .expected_color = Tags::Color::Blue},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x65, 0x04, 0x21, 0x04,
                   0x35, 0x04, 0x40, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15},
         .expected_label = "Серый",
         .expected_color = Tags::Color::Gray},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x69, 0x04, 0x17, 0x04, 0x35, 0x04,
                   0x3b, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4b, 0x04, 0x39, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d},
         .expected_label = "Зеленый",
         .expected_color = Tags::Color::Green},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x69, 0x04, 0x1e, 0x04, 0x40, 0x04,
                   0x30, 0x04, 0x3d, 0x04, 0x36, 0x04, 0x35, 0x04, 0x32, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d},
         .expected_label = "Оранжевый",
         .expected_color = Tags::Color::Orange},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x1b, 0x04, 0x38,
                   0x04, 0x3b, 0x04, 0x3e, 0x04, 0x32, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19},
         .expected_label = "Лиловый",
         .expected_color = Tags::Color::Purple},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x1a, 0x04, 0x40,
                   0x04, 0x30, 0x04, 0x41, 0x04, 0x3d, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19},
         .expected_label = "Красный",
         .expected_color = Tags::Color::Red},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x66, 0x04, 0x16, 0x04, 0x35,
                   0x04, 0x3b, 0x04, 0x42, 0x04, 0x4b, 0x04, 0x39, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17},
         .expected_label = "Желтый",
         .expected_color = Tags::Color::Yellow},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6f, 0x10, 0x52, 0x04, 0x2d, 0x04, 0x42,
                   0x04, 0x3e, 0x00, 0x20, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4c, 0x00, 0x20, 0x04,
                   0x34, 0x04, 0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x3d, 0x04, 0x3e, 0x04, 0x35, 0x00, 0x20, 0x04, 0x38,
                   0x04, 0x3c, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x42, 0x04,
                   0x4d, 0x04, 0x33, 0x04, 0x30, 0x00, 0x20, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x38, 0x04, 0x3d,
                   0x04, 0x30, 0x00, 0x20, 0x04, 0x3a, 0x04, 0x3e, 0x04, 0x42, 0x04, 0x3e, 0x04, 0x40, 0x04, 0x3e, 0x04,
                   0x33, 0x04, 0x3e, 0x00, 0x20, 0x04, 0x42, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x3d, 0x04, 0x3e, 0x00, 0x20,
                   0x04, 0x3d, 0x04, 0x35, 0x00, 0x20, 0x04, 0x3f, 0x04, 0x3e, 0x04, 0x3c, 0x04, 0x35, 0x04, 0x41, 0x04,
                   0x42, 0x04, 0x38, 0x04, 0x42, 0x04, 0x41, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x32, 0x00, 0x20, 0x04, 0x47,
                   0x04, 0x35, 0x04, 0x42, 0x04, 0x4b, 0x04, 0x40, 0x04, 0x35, 0x00, 0x20, 0x04, 0x31, 0x04, 0x38, 0x04,
                   0x42, 0x04, 0x30, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb1},
         .expected_label = "Это очень длинное имя для тэга  длина которого "
                           "точно не поместится в четыре бита",
         .expected_color = Tags::Color::Green},
        {.bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6a, 0xd8, 0x3e, 0xdd, 0x13, 0xd8, 0x3e,
                   0xdd, 0x78, 0xd8, 0x3e, 0xdd, 0x29, 0xd8, 0x3e, 0xdd, 0x73, 0xd8, 0x3d, 0xde, 0x0f, 0x08, 0x0a, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f},
         .expected_label = "🤓🥸🤩🥳😏",
         .expected_color = Tags::Color::None},
    };
    for( auto &tc : tcs ) {
        INFO(fmt::format("{} - {}", tc.expected_label, std::to_underlying(tc.expected_color)));
        auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<const std::byte *>(tc.bytes.data()), tc.bytes.size()});
        REQUIRE(tags.size() == 1);
        CHECK(tags[0] == Tags::Tag(&tc.expected_label, tc.expected_color));
    }
}

TEST_CASE(PREFIX "Can parse muliple labels at once")
{
    uint8_t plist[] = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa8, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                       0x07, 0x08, 0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34, 0x56, 0x47, 0x72, 0x65, 0x79, 0x0a,
                       0x31, 0x57, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x0a, 0x32, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67,
                       0x65, 0x0a, 0x37, 0x58, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x0a, 0x33, 0x55, 0x52, 0x65,
                       0x64, 0x0a, 0x36, 0x58, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x0a, 0x35, 0x54, 0x48, 0x6f,
                       0x6d, 0x65, 0x08, 0x11, 0x18, 0x1f, 0x27, 0x30, 0x39, 0x3f, 0x48, 0x00, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
                       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d};
    auto tags = Tags::ParseMDItemUserTags({reinterpret_cast<std::byte *>(plist), sizeof(plist)});
    std::set<std::string> labels;
    auto label = [&labels](const char *_l) { return &*labels.emplace(_l).first; };
    CHECK(tags == std::vector<Tags::Tag>{{label("Blue"), Tags::Color::Blue},
                                         {label("Grey"), Tags::Color::Gray},
                                         {label("Green"), Tags::Color::Green},
                                         {label("Orange"), Tags::Color::Orange},
                                         {label("Purple"), Tags::Color::Purple},
                                         {label("Red"), Tags::Color::Red},
                                         {label("Yellow"), Tags::Color::Yellow},
                                         {label("Home"), Tags::Color::None}});
}

TEST_CASE(PREFIX "Can read from a file")
{
    const TempTestDir dir;
    const auto path = dir.directory / "f.txt";
    struct TC {
        NSURLResourceKey key;
        id value;
        std::string expected_label;
        Tags::Color expected_color;
    } tcs[] = {
        // TODO: figure out a way of getting current Finder tags, otherwise these tests are setup-dependent
        // {NSURLTagNamesKey, @[@"Home"], "Home", Tags::Color::None},
        // {NSURLTagNamesKey, @[@"Grey"], "Grey", Tags::Color::Gray},
        // {NSURLTagNamesKey, @[@"Green"], "Green", Tags::Color::Green},
        // {NSURLTagNamesKey, @[@"Purple"], "Purple", Tags::Color::Purple},
        // {NSURLTagNamesKey, @[@"Blue"], "Blue", Tags::Color::Blue},
        // {NSURLTagNamesKey, @[@"Yellow"], "Yellow", Tags::Color::Yellow},
        // {NSURLTagNamesKey, @[@"Red"], "Red", Tags::Color::Red},
        // {NSURLTagNamesKey, @[@"Orange"], "Orange", Tags::Color::Orange},
        {.key = NSURLLabelNumberKey, .value = @(1), .expected_label = "Gray", .expected_color = Tags::Color::Gray},
        {.key = NSURLLabelNumberKey, .value = @(2), .expected_label = "Green", .expected_color = Tags::Color::Green},
        {.key = NSURLLabelNumberKey, .value = @(3), .expected_label = "Purple", .expected_color = Tags::Color::Purple},
        {.key = NSURLLabelNumberKey, .value = @(4), .expected_label = "Blue", .expected_color = Tags::Color::Blue},
        {.key = NSURLLabelNumberKey, .value = @(5), .expected_label = "Yellow", .expected_color = Tags::Color::Yellow},
        {.key = NSURLLabelNumberKey, .value = @(6), .expected_label = "Red", .expected_color = Tags::Color::Red},
        {.key = NSURLLabelNumberKey, .value = @(7), .expected_label = "Orange", .expected_color = Tags::Color::Orange},
    };
    for( auto &tc : tcs ) {
        INFO(fmt::format("{} - {} - {}", tc.key.UTF8String, tc.expected_label, std::to_underlying(tc.expected_color)));
        close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR));
        NSURL *const url = [[NSURL alloc] initFileURLWithFileSystemRepresentation:path.c_str()
                                                                      isDirectory:false
                                                                    relativeToURL:nil];
        CHECK([url setResourceValue:tc.value forKey:tc.key error:nil]);
        auto tags = Tags::ReadTags(path);
        REQUIRE(tags.size() == 1);
        CHECK(tags[0].Label() == tc.expected_label);
        CHECK(tags[0].Color() == tc.expected_color);
        unlink(path.c_str());
    }
}

TEST_CASE(PREFIX "BuildMDItemUserTags")
{
    std::set<std::string> labels;
    auto tag = [&labels](const char *_l, Tags::Color _c) { return Tags::Tag(&*labels.emplace(_l).first, _c); };

    struct TC {
        std::vector<Tags::Tag> labels;
        std::vector<unsigned char> expected_bytes;
    } const tcs[] = {
        {.labels = {}, .expected_bytes = {}},
        {.labels = {tag("None", Tags::Color::None)},
         .expected_bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x54, 0x4e, 0x6f,
                            0x6e, 0x65, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f}},
        {.labels = {tag("Gray", Tags::Color::Gray)},
         .expected_bytes = {0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x47, 0x72,
                            0x61, 0x79, 0x0a, 0x31, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11}},
        {.labels = {tag("Green", Tags::Color::Green)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x57, 0x47, 0x72,
                             0x65, 0x65, 0x6e, 0x0a, 0x32, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12}}},
        {.labels = {tag("Purple", Tags::Color::Purple)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x50, 0x75, 0x72,
                             0x70, 0x6c, 0x65, 0x0a, 0x33, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                             0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13}}},
        {.labels = {tag("Blue", Tags::Color::Blue)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x56, 0x42, 0x6c,
                             0x75, 0x65, 0x0a, 0x34, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                             0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11}}},
        {.labels = {tag("Yellow", Tags::Color::Yellow)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x59, 0x65, 0x6c,
                             0x6c, 0x6f, 0x77, 0x0a, 0x35, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                             0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13}}},
        {.labels = {tag("Red", Tags::Color::Red)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x55, 0x52, 0x65,
                             0x64, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10}}},
        {.labels = {tag("Orange", Tags::Color::Orange)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x58, 0x4f, 0x72, 0x61,
                             0x6e, 0x67, 0x65, 0x0a, 0x37, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                             0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13}}},
        {.labels = {tag("Blue", Tags::Color::Blue),
                    tag("Grey", Tags::Color::Gray),
                    tag("Green", Tags::Color::Green),
                    tag("Orange", Tags::Color::Orange),
                    tag("Purple", Tags::Color::Purple),
                    tag("Red", Tags::Color::Red),
                    tag("Yellow", Tags::Color::Yellow),
                    tag("Home", Tags::Color::None)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa8, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
                             0x07, 0x08, 0x56, 0x42, 0x6c, 0x75, 0x65, 0x0a, 0x34, 0x56, 0x47, 0x72, 0x65, 0x79, 0x0a,
                             0x31, 0x57, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x0a, 0x32, 0x58, 0x4f, 0x72, 0x61, 0x6e, 0x67,
                             0x65, 0x0a, 0x37, 0x58, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x0a, 0x33, 0x55, 0x52, 0x65,
                             0x64, 0x0a, 0x36, 0x58, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x0a, 0x35, 0x54, 0x48, 0x6f,
                             0x6d, 0x65, 0x08, 0x11, 0x18, 0x1f, 0x27, 0x30, 0x39, 0x3f, 0x48, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d}}},
        {.labels = {tag("This is a very long and meaningless tag label", Tags::Color::Red)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x5f, 0x10, 0x2f, 0x54,
                             0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20,
                             0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x69,
                             0x6e, 0x67, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x74, 0x61, 0x67, 0x20, 0x6c, 0x61, 0x62,
                             0x65, 0x6c, 0x0a, 0x36, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c}}},
        {.labels = {tag("Привет!!!", Tags::Color::Blue)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6b, 0x04, 0x1f, 0x04,
                             0x40, 0x04, 0x38, 0x04, 0x32, 0x04, 0x35, 0x04, 0x42, 0x00, 0x21, 0x00, 0x21, 0x00,
                             0x21, 0x00, 0x0a, 0x00, 0x34, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
                             0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21}}},
        {.labels = {tag("Синий", Tags::Color::Blue)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x67, 0x04, 0x21, 0x04, 0x38,
                             0x04, 0x3d, 0x04, 0x38, 0x04, 0x39, 0x00, 0x0a, 0x00, 0x34, 0x08, 0x0a, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19}}},
        {.labels = {tag("Зеленый", Tags::Color::Green)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x69, 0x04, 0x17,
                             0x04, 0x35, 0x04, 0x3b, 0x04, 0x35, 0x04, 0x3d, 0x04, 0x4b, 0x04, 0x39, 0x00,
                             0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d}}},
        {.labels = {tag("Это очень длинное имя для тэга  длина которого точно "
                        "не поместится в четыре бита",
                        Tags::Color::Green)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6f, 0x10, 0x52, 0x04, 0x2d,
                             0x04, 0x42, 0x04, 0x3e, 0x00, 0x20, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x35, 0x04, 0x3d, 0x04,
                             0x4c, 0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x3d, 0x04, 0x3e,
                             0x04, 0x35, 0x00, 0x20, 0x04, 0x38, 0x04, 0x3c, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x34, 0x04,
                             0x3b, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x42, 0x04, 0x4d, 0x04, 0x33, 0x04, 0x30, 0x00, 0x20,
                             0x00, 0x20, 0x04, 0x34, 0x04, 0x3b, 0x04, 0x38, 0x04, 0x3d, 0x04, 0x30, 0x00, 0x20, 0x04,
                             0x3a, 0x04, 0x3e, 0x04, 0x42, 0x04, 0x3e, 0x04, 0x40, 0x04, 0x3e, 0x04, 0x33, 0x04, 0x3e,
                             0x00, 0x20, 0x04, 0x42, 0x04, 0x3e, 0x04, 0x47, 0x04, 0x3d, 0x04, 0x3e, 0x00, 0x20, 0x04,
                             0x3d, 0x04, 0x35, 0x00, 0x20, 0x04, 0x3f, 0x04, 0x3e, 0x04, 0x3c, 0x04, 0x35, 0x04, 0x41,
                             0x04, 0x42, 0x04, 0x38, 0x04, 0x42, 0x04, 0x41, 0x04, 0x4f, 0x00, 0x20, 0x04, 0x32, 0x00,
                             0x20, 0x04, 0x47, 0x04, 0x35, 0x04, 0x42, 0x04, 0x4b, 0x04, 0x40, 0x04, 0x35, 0x00, 0x20,
                             0x04, 0x31, 0x04, 0x38, 0x04, 0x42, 0x04, 0x30, 0x00, 0x0a, 0x00, 0x32, 0x08, 0x0a, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0xb1}}},
        {.labels = {tag("🤓🥸🤩🥳😏", Tags::Color::None)},
         .expected_bytes = {{0x62, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x30, 0x30, 0xa1, 0x01, 0x6a, 0xd8, 0x3e,
                             0xdd, 0x13, 0xd8, 0x3e, 0xdd, 0x78, 0xd8, 0x3e, 0xdd, 0x29, 0xd8, 0x3e, 0xdd,
                             0x73, 0xd8, 0x3d, 0xde, 0x0f, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                             0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f}}},
    };

    for( const auto &tc : tcs ) {
        auto bytes = Tags::BuildMDItemUserTags(tc.labels);
        CHECK(tc.expected_bytes ==
              std::vector<unsigned char>{reinterpret_cast<const unsigned char *>(bytes.data()),
                                         reinterpret_cast<const unsigned char *>(bytes.data() + bytes.size())});
    }
}

TEST_CASE(PREFIX "Our tags can be read back by Cocoa")
{
    std::set<std::string> labels;
    auto tag = [&labels](const char *_l, Tags::Color _c) { return Tags::Tag(&*labels.emplace(_l).first, _c); };
    const TempTestDir dir;
    const auto path = dir.directory / "f.txt";
    close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR));
    struct TC {
        std::vector<Tags::Tag> tags;
        NSArray<NSString *> *expected_labels;
        Tags::Color expected_color;
    } const tcs[] = {
        {.tags = {}, .expected_labels = @[], .expected_color = Tags::Color::None},
        {.tags = {tag("Hello!", Tags::Color::Green)},
         .expected_labels = @[@"Hello!"],
         .expected_color = Tags::Color::Green},
        {.tags = {tag("N", Tags::Color::None)}, .expected_labels = @[@"N"], .expected_color = Tags::Color::None},
        {.tags = {tag("Gy", Tags::Color::Gray)}, .expected_labels = @[@"Gy"], .expected_color = Tags::Color::Gray},
        {.tags = {tag("Gn", Tags::Color::Green)}, .expected_labels = @[@"Gn"], .expected_color = Tags::Color::Green},
        {.tags = {tag("P", Tags::Color::Purple)}, .expected_labels = @[@"P"], .expected_color = Tags::Color::Purple},
        {.tags = {tag("B", Tags::Color::Blue)}, .expected_labels = @[@"B"], .expected_color = Tags::Color::Blue},
        {.tags = {tag("Y", Tags::Color::Yellow)}, .expected_labels = @[@"Y"], .expected_color = Tags::Color::Yellow},
        {.tags = {tag("R", Tags::Color::Red)}, .expected_labels = @[@"R"], .expected_color = Tags::Color::Red},
        {.tags = {tag("O", Tags::Color::Orange)}, .expected_labels = @[@"O"], .expected_color = Tags::Color::Orange},
        {.tags = {tag("1", Tags::Color::Orange), tag("2", Tags::Color::Blue)},
         .expected_labels = @[@"1", @"2"],
         .expected_color = Tags::Color::Orange},
        {.tags = {tag("2", Tags::Color::Blue), tag("1", Tags::Color::Orange)},
         .expected_labels = @[@"2", @"1"],
         .expected_color = Tags::Color::Blue},
        {.tags = {tag("🤡", Tags::Color::Green)}, .expected_labels = @[@"🤡"], .expected_color = Tags::Color::Green},
    };

    for( auto &tc : tcs ) {
        CHECK(Tags::WriteTags(path, tc.tags));
        NSURL *const url = [[NSURL alloc] initFileURLWithFileSystemRepresentation:path.c_str()
                                                                      isDirectory:false
                                                                    relativeToURL:nil];

        id tag_names;
        CHECK([url getResourceValue:&tag_names forKey:NSURLTagNamesKey error:nil]);
        if( tc.expected_labels.count )
            CHECK([nc::objc_cast<NSArray>(tag_names) isEqualToArray:tc.expected_labels]);
        else
            CHECK(tag_names == nil);

        id number;
        CHECK([url getResourceValue:&number forKey:NSURLLabelNumberKey error:nil]);
        CHECK(nc::objc_cast<NSNumber>(number).integerValue == std::to_underlying(tc.expected_color));
    }
}

TEST_CASE(PREFIX "Spotlight detects items with new tags invented by NC")
{
    // Need to place these temp files into an indexable location (which the temp dir is not)
    auto basepath = std::filesystem::path{nc::base::CommonPaths::Library()} / "__nc_testing_tags_ut__";
    std::filesystem::create_directory(basepath);
    auto cleanup = at_scope_end([basepath] { std::filesystem::remove_all(basepath); });

    const std::string label =
        fmt::format("Hello! This is a new tag created via Nimble Commander! My PID is {}", getpid());
    const Tags::Color color = Tags::Color::Orange;

    {
        // Write a temp file with a newly invented tag
        const auto path = basepath / "f.txt";
        CHECK(close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
        CHECK(Tags::WriteTags(path, std::vector<Tags::Tag>{{&label, color}}));
        CHECK(system(fmt::format("mdimport {}", path.c_str()).c_str()) == 0);
    }

    // Try a few times to find the new tag via Spotlight, need multiple attempts since there's still a race condition
    // even after an explicit call to mdimport
    for( int attempt = 0; attempt < 50; ++attempt ) {
        auto all_tags = Tags::GatherAllItemsTags();
        if( std::ranges::find(all_tags, Tags::Tag{&label, color}) == all_tags.end() ) {
            std::this_thread::sleep_for(std::chrono::milliseconds{100});
            continue;
        }

        // Sucessfully found the newly created tag among all tags found via Spotlight, i.e. success
        return;
    }

    // Failed to find the new tag after the number of attempts
    FAIL();
}

TEST_CASE(PREFIX "GatherAllItemsWithTag")
{
    // Need to place these temp files into an indexable location (which the temp dir is not)
    auto basepath = std::filesystem::path{nc::base::CommonPaths::Library()} / "__nc_testing_tags_ut__";
    std::filesystem::create_directory(basepath);
    auto cleanup = at_scope_end([basepath] { std::filesystem::remove_all(basepath); });
    const std::set<std::filesystem::path> filepaths = {basepath / "f1.txt", basepath / "f2.txt", basepath / "f3.txt"};

    const std::string labels[] = {
        fmt::format("simple_label_{}", getpid()),
        fmt::format("label with spaces {}", getpid()),
        fmt::format("this label 'even' has \"quotes\" {}", getpid()),
        fmt::format("gibberish |&;<>()$`\t! {}", getpid()),
        fmt::format("even emojii are supported! 🤯 {}", getpid()),
        fmt::format("а вот этот лейбл написан по-русски {}", getpid()),
    };
    const Tags::Color color = Tags::Color::Orange;

    for( const std::string &label : labels ) {
        // Write temp files with a newly invented tag
        for( const std::filesystem::path &filepath : filepaths ) {
            CHECK(close(open(filepath.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
            CHECK(Tags::WriteTags(filepath, std::vector<Tags::Tag>{{&label, color}}));
        }

        // Tell Spotlight to look into the dir
        CHECK(system(fmt::format("mdimport {}", basepath.c_str()).c_str()) == 0);

        // Try a few times to find the items via Spotlight, need multiple attempts since there's still a race condition
        // even after an explicit call to mdimport
        for( int attempt = 0; attempt < 50; ++attempt ) {
            const auto items = Tags::GatherAllItemsWithTag(label);
            if( std::set<std::filesystem::path>{items.begin(), items.end()} == filepaths )
                break; // Sucessfully found the newly created tag among all tags found via Spotlight, i.e. success
            if( attempt == 9 )
                FAIL(); // Failed to find the new tag after the number of attempts
            std::this_thread::sleep_for(std::chrono::milliseconds{100});
        }

        // Remove the temp files
        for( const std::filesystem::path &filepath : filepaths ) {
            std::filesystem::remove(filepath);
        }
    }
}

TEST_CASE(PREFIX "ChangeColorOfAllItemsWithTag")
{
    // Need to place these temp files into an indexable location (which the temp dir is not)
    auto basepath = std::filesystem::path{nc::base::CommonPaths::Library()} / "__nc_testing_tags_ut__";
    std::filesystem::create_directory(basepath);
    auto cleanup = at_scope_end([basepath] { std::filesystem::remove_all(basepath); });
    const std::filesystem::path p1 = basepath / "f1";
    const std::filesystem::path p2 = basepath / "f2";
    const std::filesystem::path p3 = basepath / "f3";
    const std::string label1 = fmt::format("the first temporary label for ChangeColorOfAllItemsWithTag {}", getpid());
    const std::string label2 = fmt::format("the second temporary label for ChangeColorOfAllItemsWithTag {}", getpid());
    const Tags::Color orig_color1 = Tags::Color::Orange;
    const Tags::Color orig_color2 = Tags::Color::Blue;

    // Write temp files with the newly invented tags
    CHECK(close(open(p1.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p1, std::vector<Tags::Tag>{{&label1, orig_color1}}));
    CHECK(close(open(p2.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p2, std::vector<Tags::Tag>{{&label1, orig_color1}, {&label2, orig_color2}}));
    CHECK(close(open(p3.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p3, std::vector<Tags::Tag>{{&label2, orig_color2}, {&label1, orig_color1}}));

    // Tell Spotlight to look into the dir
    CHECK(system(fmt::format("mdimport {}", basepath.c_str()).c_str()) == 0);

    // Try a few times to find the items via Spotlight, need multiple attempts since there's still a race condition
    // even after an explicit call to mdimport
    for( int attempt = 0; attempt < 50; ++attempt ) {
        const auto items = Tags::GatherAllItemsWithTag(label1);
        if( std::set<std::filesystem::path>{items.begin(), items.end()} == std::set<std::filesystem::path>{p1, p2, p3} )
            break; // Sucessfully found the newly created tag among all tags found via Spotlight, i.e. success
        if( attempt == 9 )
            FAIL(); // Failed to find the new tag after the number of attempts
        std::this_thread::sleep_for(std::chrono::milliseconds{100});
    }

    // Change the color for one of the new tags
    const Tags::Color new_color1 = Tags::Color::Purple;
    Tags::ChangeColorOfAllItemsWithTag(label1, new_color1);

    // Verify the change
    CHECK(Tags::ReadTags(p1) == std::vector<Tags::Tag>{{&label1, new_color1}});
    CHECK(Tags::ReadTags(p2) == std::vector<Tags::Tag>{{&label1, new_color1}, {&label2, orig_color2}});
    CHECK(Tags::ReadTags(p3) == std::vector<Tags::Tag>{{&label2, orig_color2}, {&label1, new_color1}});
}

TEST_CASE(PREFIX "ChangeLabelOfAllItemsWithTag")
{
    // Need to place these temp files into an indexable location (which the temp dir is not)
    auto basepath = std::filesystem::path{nc::base::CommonPaths::Library()} / "__nc_testing_tags_ut__";
    std::filesystem::create_directory(basepath);
    auto cleanup = at_scope_end([basepath] { std::filesystem::remove_all(basepath); });
    const std::filesystem::path p1 = basepath / "f1";
    const std::filesystem::path p2 = basepath / "f2";
    const std::filesystem::path p3 = basepath / "f3";
    const std::string label1 = fmt::format("the first temporary label for ChangeLabelOfAllItemsWithTag {}", getpid());
    const std::string label2 = fmt::format("the second temporary label for ChangeLabelOfAllItemsWithTag {}", getpid());
    const Tags::Color color1 = Tags::Color::Orange;
    const Tags::Color color2 = Tags::Color::Blue;

    // Write temp files with the newly invented tags
    CHECK(close(open(p1.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p1, std::vector<Tags::Tag>{{&label1, color1}}));
    CHECK(close(open(p2.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p2, std::vector<Tags::Tag>{{&label1, color1}, {&label2, color2}}));
    CHECK(close(open(p3.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p3, std::vector<Tags::Tag>{{&label2, color2}, {&label1, color1}}));

    // Tell Spotlight to look into the dir
    CHECK(system(fmt::format("mdimport {}", basepath.c_str()).c_str()) == 0);

    // Try a few times to find the items via Spotlight, need multiple attempts since there's still a race condition
    // even after an explicit call to mdimport
    for( int attempt = 0; attempt < 50; ++attempt ) {
        const auto items = Tags::GatherAllItemsWithTag(label1);
        if( std::set<std::filesystem::path>{items.begin(), items.end()} == std::set<std::filesystem::path>{p1, p2, p3} )
            break; // Sucessfully found the newly created tag among all tags found via Spotlight, i.e. success
        if( attempt == 9 )
            FAIL(); // Failed to find the new tag after the number of attempts
        std::this_thread::sleep_for(std::chrono::milliseconds{100});
    }

    // Change the label for one of the new tags
    const std::string new_label1 = fmt::format("renamed label for ChangeLabelOfAllItemsWithTag {}", getpid());
    Tags::ChangeLabelOfAllItemsWithTag(label1, new_label1);

    // Verify the change
    CHECK(Tags::ReadTags(p1) == std::vector<Tags::Tag>{{&new_label1, color1}});
    CHECK(Tags::ReadTags(p2) == std::vector<Tags::Tag>{{&new_label1, color1}, {&label2, color2}});
    CHECK(Tags::ReadTags(p3) == std::vector<Tags::Tag>{{&label2, color2}, {&new_label1, color1}});
}

TEST_CASE(PREFIX "AddTag")
{
    // TODO: add a unit test for directories as well
    using C = Tags::Color;
    auto tag = [](std::string_view _l, Tags::Color _c) { return Tags::Tag(Tags::Tag::Internalize(_l), _c); };
    const TempTestDir dir;
    const auto path = dir.directory / "f.txt";
    close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR));
    struct TC {
        std::vector<Tags::Tag> initial;
        Tags::Tag to_add;
        std::vector<Tags::Tag> expected;
    } const tcs[] = {
        {.initial = {}, .to_add = tag("A", C::Red), .expected = {tag("A", C::Red)}},
        {.initial = {tag("A", C::Red)}, .to_add = tag("A", C::Red), .expected = {tag("A", C::Red)}},
        {.initial = {tag("A", C::Blue)}, .to_add = tag("A", C::Red), .expected = {tag("A", C::Red)}},
        {.initial = {tag("B", C::Blue)}, .to_add = tag("A", C::Red), .expected = {tag("B", C::Blue), tag("A", C::Red)}},
        {.initial = {tag("B", C::Blue), tag("A", C::Purple)},
         .to_add = tag("A", C::Red),
         .expected = {tag("B", C::Blue), tag("A", C::Red)}},
        {.initial = {tag("A", C::Purple), tag("B", C::Blue)},
         .to_add = tag("A", C::Red),
         .expected = {tag("A", C::Red), tag("B", C::Blue)}},
    };
    for( auto &tc : tcs ) {
        CHECK(Tags::WriteTags(path, tc.initial));
        CHECK(Tags::AddTag(path, tc.to_add));
        CHECK(Tags::ReadTags(path) == tc.expected);
    }
}

TEST_CASE(PREFIX "RemoveTag")
{
    // TODO: add a unit test for directories as well
    using C = Tags::Color;
    auto tag = [](std::string_view _l, Tags::Color _c) { return Tags::Tag(Tags::Tag::Internalize(_l), _c); };
    const TempTestDir dir;
    const auto path = dir.directory / "f.txt";
    close(open(path.c_str(), O_CREAT, S_IRUSR | S_IWUSR));
    struct TC {
        std::vector<Tags::Tag> initial;
        std::string to_remove;
        std::vector<Tags::Tag> expected;
    } const tcs[] = {
        {.initial = {}, .to_remove = "A", .expected = {}},
        {.initial = {tag("A", C::Red)}, .to_remove = "A", .expected = {}},
        {.initial = {tag("A", C::Red)}, .to_remove = "B", .expected = {tag("A", C::Red)}},
        {.initial = {tag("B", C::Blue), tag("A", C::Purple)}, .to_remove = "A", .expected = {tag("B", C::Blue)}},
        {.initial = {tag("B", C::Blue), tag("A", C::Purple)}, .to_remove = "B", .expected = {tag("A", C::Purple)}},
        {.initial = {tag("B", C::Blue), tag("A", C::Purple)},
         .to_remove = "C",
         .expected = {tag("B", C::Blue), tag("A", C::Purple)}},
    };
    for( auto &tc : tcs ) {
        CHECK(Tags::WriteTags(path, tc.initial));
        CHECK(Tags::RemoveTag(path, tc.to_remove));
        CHECK(Tags::ReadTags(path) == tc.expected);
    }
}

TEST_CASE(PREFIX "RemoveTagFromAllItems")
{
    // Need to place these temp files into an indexable location (which the temp dir is not)
    auto basepath = std::filesystem::path{nc::base::CommonPaths::Library()} / "__nc_testing_tags_ut__";
    std::filesystem::create_directory(basepath);
    auto cleanup = at_scope_end([basepath] { std::filesystem::remove_all(basepath); });
    const std::filesystem::path p1 = basepath / "f1";
    const std::filesystem::path p2 = basepath / "f2";
    const std::filesystem::path p3 = basepath / "f3";
    const std::string label1 = fmt::format("the first temporary label for RemoveTagFromAllItems {}", getpid());
    const std::string label2 = fmt::format("the second temporary label for RemoveTagFromAllItems {}", getpid());
    const Tags::Color color1 = Tags::Color::Orange;
    const Tags::Color color2 = Tags::Color::Blue;

    // Write temp files with the newly invented tags
    CHECK(close(open(p1.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p1, std::vector<Tags::Tag>{{&label1, color1}}));
    CHECK(close(open(p2.c_str(), O_CREAT, S_IRUSR | S_IWUSR)) == 0);
    CHECK(Tags::WriteTags(p2, std::vector<Tags::Tag>{{&label1, color1}, {&label2, color2}}));
    CHECK(mkdir(p3.c_str(), S_IRUSR | S_IWUSR) == 0);
    CHECK(Tags::WriteTags(p3, std::vector<Tags::Tag>{{&label2, color2}, {&label1, color1}}));

    // Tell Spotlight to look into the dir
    CHECK(system(fmt::format("mdimport {}", basepath.c_str()).c_str()) == 0);

    // Try a few times to find the items via Spotlight, need multiple attempts since there's still a race condition
    // even after an explicit call to mdimport
    for( int attempt = 0; attempt < 50; ++attempt ) {
        const auto items = Tags::GatherAllItemsWithTag(label1);
        if( std::set<std::filesystem::path>{items.begin(), items.end()} == std::set<std::filesystem::path>{p1, p2, p3} )
            break; // Sucessfully found the newly created tag among all tags found via Spotlight, i.e. success
        if( attempt == 9 )
            FAIL(); // Failed to find the new tag after the number of attempts
        std::this_thread::sleep_for(std::chrono::milliseconds{100});
    }

    // Remove the first tag from all items
    Tags::RemoveTagFromAllItems(label1);

    // Verify the change
    CHECK(Tags::ReadTags(p1).empty());
    CHECK(Tags::ReadTags(p2) == std::vector<Tags::Tag>{{&label2, color2}});
    CHECK(Tags::ReadTags(p3) == std::vector<Tags::Tag>{{&label2, color2}});
}
